<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Collaborative Whiteboard ‚Äî Improved</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0f1724; --panel:#0b1220; --muted:#94a3b8; --accent:#7c3aed; --card:#071029;
      --toolbar-h:64px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,system-ui,Arial;height:100vh;display:flex;flex-direction:column;background:linear-gradient(180deg,#071029 0%, #071833 100%);color:#e6eef8}
    #toolbar{height:var(--toolbar-h);display:flex;align-items:center;padding:10px 16px;background:linear-gradient(90deg, rgba(255,255,255,0.03), transparent);gap:12px;backdrop-filter: blur(6px)}
    .group{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.03);padding:8px;border-radius:10px}
    button,input,select,textarea{font-family:inherit;font-size:14px}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.active{border-color:var(--accent);box-shadow:0 6px 18px rgba(124,58,237,0.16);color:#fff}
    #left{display:flex;gap:10px;align-items:center}
    #right{margin-left:auto;display:flex;gap:10px;align-items:center;color:var(--muted)}
    #canvas-wrap{position:relative;flex:1;display:flex;gap:12px;padding:12px}
    #canvas{flex:1;border-radius:12px;background:white;display:block;cursor:crosshair;box-shadow:0 10px 30px rgba(2,6,23,0.6)}
    #sticky-area{position:absolute;left:32px;top:92px;right:32px;bottom:32px;pointer-events:none}
    .sticky{position:absolute; width:200px; min-height:100px; background:linear-gradient(180deg,#fff8b3,#fff1a8); color:#111; padding:10px; box-shadow:0 8px 24px rgba(2,6,23,0.6); resize:both; overflow:auto; pointer-events:auto; border-radius:8px; border:1px solid rgba(0,0,0,0.05)}
    .sticky .handle{display:block; background:linear-gradient(90deg,#f59e0b,#f97316); height:18px; border-radius:6px; margin-bottom:6px; cursor:grab}
    .controls small{color:var(--muted)}
    #graph-modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--panel);padding:16px;border-radius:12px;box-shadow:0 20px 60px rgba(2,6,23,0.7);display:none;z-index:2000;width:420px;color:#e6eef8}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type="text"], textarea{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef8;width:100%}
    .small-muted{font-size:12px;color:var(--muted)}
    #clients{min-width:30px;text-align:center;background:rgba(255,255,255,0.02);padding:6px;border-radius:8px}
    .toolbar-icon{width:36px;height:36px;display:flex;align-items:center;justify-content:center;border-radius:8px}
  </style>
</head>
<body>
  <div id="toolbar">
    <div id="left" class="group">
      <button id="tool-pen" class="active toolbar-icon">‚úèÔ∏è</button>
      <button id="tool-eraser" class="toolbar-icon">üßΩ</button>
      <div style="display:flex;flex-direction:column">
        <label class="small-muted">Color</label>
        <input id="color" type="color" value="#000000">
      </div>
      <div style="display:flex;flex-direction:column">
        <label class="small-muted">Size</label>
        <input id="size" type="range" min="1" max="30" value="3">
      </div>
      <div style="display:flex;flex-direction:column">
        <label class="small-muted">Shape</label>
        <select id="shape-select"><option value="none">None</option><option value="line">Line</option><option value="rect">Rectangle</option><option value="circle">Circle</option></select>
      </div>
      <button id="toggle-grid" class="toolbar-icon">‚ñ¶</button>
      <button id="add-sticky" class="toolbar-icon">üóíÔ∏è</button>
      <button id="graph-btn" class="toolbar-icon">üìà</button>
      <button id="clear" class="toolbar-icon">üßπ</button>
    </div>
    <div id="right">
      <div class="small-muted">Connected</div>
      <div id="clients" title="Connected clients">0</div>
      <div class="small-muted">Status</div>
      <div id="status" class="small-muted">Ready</div>
    </div>
  </div>

  <div id="canvas-wrap">
    <canvas id="canvas" width="1200" height="720"></canvas>
    <div id="sticky-area"></div>
  </div>

  <div id="graph-modal">
    <h3 style="margin:0 0 8px 0">Insert graph data</h3>
    <label>Values (comma-separated)</label>
    <input id="graph-data" type="text" placeholder="e.g. 10, 20, 15, 30, 50">
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="draw-graph">Draw</button>
      <button id="close-graph">Close</button>
    </div>
  </div>

  <script>
    // ---- Helpers and setup ----
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('color');
    const sizePicker = document.getElementById('size');
    const clearBtn = document.getElementById('clear');
    const clientsEl = document.getElementById('clients');
    const stickyArea = document.getElementById('sticky-area');
    const toggleGridBtn = document.getElementById('toggle-grid');
    const addStickyBtn = document.getElementById('add-sticky');
    const graphBtn = document.getElementById('graph-btn');
    const graphModal = document.getElementById('graph-modal');
    const statusEl = document.getElementById('status');

    let currentTool = 'pen';
    let currentShape = 'none';
    let drawing=false, lastX=0, lastY=0;
    let shapeStart=null;
    let gridOn=false;

    // websocket
    const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
    const socket = new WebSocket(`${wsScheme}://${location.host}/ws`);

    socket.addEventListener('open', ()=>{ statusEl.textContent='Connected'; });
    socket.addEventListener('close', ()=>{ statusEl.textContent='Disconnected'; });
    socket.addEventListener('error', ()=>{ statusEl.textContent='Error'; });

    socket.addEventListener('message', (evt)=>{
      try{
        const msg = JSON.parse(evt.data);
        handleMessage(msg);
      }catch(e){ console.error('Invalid ws msg', e); }
    });

    function sendMessage(obj){ try{ socket.send(JSON.stringify(obj)); }catch(e){ console.error(e); } }

    // ---- drawing primitives ----
    function drawLine(x1,y1,x2,y2,color,size,composite='source-over'){
      ctx.globalCompositeOperation = composite;
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.globalCompositeOperation = 'source-over';
    }
    function drawRect(x,y,w,h,color,size,fill=false){
      ctx.lineWidth = size; ctx.strokeStyle = color;
      if(fill){ ctx.fillStyle = color; ctx.fillRect(x,y,w,h); }
      ctx.strokeRect(x,y,w,h);
    }
    function drawCircle(cx,cy,r,color,size,fill=false){
      ctx.lineWidth = size; ctx.strokeStyle = color;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); if(fill){ ctx.fillStyle=color; ctx.fill(); } ctx.stroke();
    }

    // ---- canvas resize & preserve content ----
    function resizeCanvas(){
      const w = Math.max(800, Math.min(window.innerWidth-80, 1400));
      const h = Math.max(400, window.innerHeight - document.getElementById('toolbar').offsetHeight - 80);
      // preserve image
      const tmp = document.createElement('canvas');
      tmp.width = canvas.width; tmp.height = canvas.height;
      tmp.getContext('2d').drawImage(canvas,0,0);
      canvas.width = w; canvas.height = h;
      ctx.drawImage(tmp,0,0);
      if(gridOn) drawGrid();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // ---- tool selection ----
    document.getElementById('tool-pen').onclick = ()=> selectTool('pen');
    document.getElementById('tool-eraser').onclick = ()=> selectTool('eraser');
    function selectTool(t){
      currentTool = t;
      document.querySelectorAll('.toolbar-icon').forEach(b=>b.classList.remove('active'));
      if(t==='pen') document.getElementById('tool-pen').classList.add('active');
      else document.getElementById('tool-eraser').classList.add('active');
    }
    document.getElementById('shape-select').addEventListener('change', (e)=> currentShape = e.target.value);

    toggleGridBtn.addEventListener('click', ()=>{ gridOn = !gridOn; redrawCanvas(); if(gridOn) drawGrid(); toggleGridBtn.classList.toggle('active', gridOn);} );

    // ---- mouse drawing & shapes ----
    canvas.addEventListener('mousedown', (e)=>{
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left; lastY = e.clientY - rect.top;
      shapeStart = {x:lastX,y:lastY};
    });
    canvas.addEventListener('mouseup', (e)=>{
      if(!drawing) return;
      drawing = false;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const color = colorPicker.value, size = parseInt(sizePicker.value,10);
      if(currentShape !== 'none' && shapeStart){
        if(currentShape==='line'){
          drawLine(shapeStart.x,shapeStart.y,x,y,color,size);
          sendMessage({type:'draw', sub:'line', x1:shapeStart.x,y1:shapeStart.y,x2:x,y2:y,color,size});
        }else if(currentShape==='rect'){
          const w = x-shapeStart.x, h = y-shapeStart.y;
          drawRect(shapeStart.x,shapeStart.y,w,h,color,size);
          sendMessage({type:'draw', sub:'rect', x:shapeStart.x,y:shapeStart.y,w,h,color,size});
        }else if(currentShape==='circle'){
          const dx = x-shapeStart.x, dy = y-shapeStart.y, r = Math.sqrt(dx*dx+dy*dy);
          drawCircle(shapeStart.x,shapeStart.y,r,color,size);
          sendMessage({type:'draw', sub:'circle', x:shapeStart.x,y:shapeStart.y,r,color,size});
        }
      }
      shapeStart = null;
    });
    canvas.addEventListener('mousemove', (e)=>{
      if(!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;
      const color = colorPicker.value, size = parseInt(sizePicker.value,10);
      if(currentShape==='none'){
        if(currentTool==='pen'){
          drawLine(lastX,lastY,x,y,color,size,'source-over');
          sendMessage({type:'draw', sub:'free', x1:lastX,y1:lastY,x2:x,y2:y,color,size});
        }else if(currentTool==='eraser'){
          drawLine(lastX,lastY,x,y,'#ffffff', size*3, 'source-over');
          sendMessage({type:'draw', sub:'eraser', x1:lastX,y1:lastY,x2:x,y2:y, size:size*3});
        }
        lastX = x; lastY = y;
      }else{
        // preview current shape
        redrawCanvas();
        if(gridOn) drawGrid();
        const sx = shapeStart.x, sy = shapeStart.y;
        ctx.save(); ctx.setLineDash([6,4]); ctx.strokeStyle = color; ctx.lineWidth = size;
        if(currentShape==='line'){ ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(x,y); ctx.stroke(); }
        else if(currentShape==='rect'){ ctx.strokeRect(sx,sy,x-sx,y-sy); }
        else if(currentShape==='circle'){ const dx=x-sx,dy=y-sy,r=Math.sqrt(dx*dx+dy*dy); ctx.beginPath(); ctx.arc(sx,sy,r,0,Math.PI*2); ctx.stroke(); }
        ctx.restore();
      }
    });

    clearBtn.addEventListener('click', ()=>{ ctx.clearRect(0,0,canvas.width,canvas.height); if(gridOn) drawGrid(); sendMessage({type:'clear'}); });

    // ---- stickies: authoritative with IDs ----
    const stickies = {}; // id -> element

    function createStickyElement(s){
      // s: {id,x,y,html,z}
      if(stickies[s.id]) return stickies[s.id];
      const el = document.createElement('div'); el.className='sticky'; el.style.left = (s.x||60)+'px'; el.style.top = (s.y||60)+'px'; el.style.zIndex = s.z || 1;
      el.dataset.id = s.id;
      // handle
      const handle = document.createElement('div'); handle.className='handle'; handle.textContent = '';
      el.appendChild(handle);
      const content = document.createElement('div'); content.contentEditable = true; content.className='content'; content.innerHTML = s.html || '';
      content.style.minHeight = '50px';
      el.appendChild(content);
      stickyArea.appendChild(el);
      // drag via handle
      makeDraggable(el, handle);
      // editing
      content.addEventListener('input', (ev)=>{
        sendMessage({type:'sticky', action:'edit', id: el.dataset.id, html: content.innerHTML});
      });
      // double-click to delete (on handle)
      handle.addEventListener('dblclick', ()=>{
        const id = el.dataset.id;
        el.remove(); delete stickies[id];
        sendMessage({type:'sticky', action:'delete', id});
      });
      stickies[s.id] = el;
      return el;
    }

    function makeDraggable(el, handle){
      handle.addEventListener('mousedown', (e)=>{
        e.preventDefault();
        let startX = e.clientX, startY = e.clientY;
        const startLeft = parseInt(el.style.left||0,10), startTop = parseInt(el.style.top||0,10);
        function mm(ev){ const nx = startLeft + (ev.clientX-startX), ny = startTop + (ev.clientY-startY); el.style.left = nx+'px'; el.style.top = ny+'px'; }
        function mu(ev){ document.removeEventListener('mousemove',mm); document.removeEventListener('mouseup',mu); sendMessage({type:'sticky', action:'move', id: el.dataset.id, x: parseInt(el.style.left), y: parseInt(el.style.top)}); }
        document.addEventListener('mousemove',mm); document.addEventListener('mouseup',mu);
      });
    }

    addStickyBtn.addEventListener('click', ()=>{
      // create local id and element immediately for snappy UI, server will confirm
      const id = 's-' + Date.now() + '-' + Math.floor(Math.random()*1000);
      const s = {id, x:60, y:60, html:'<strong>New note</strong><br>Double-click the handle to delete', z: Date.now()%1000};
      createStickyElement(s);
      sendMessage({type:'sticky', action:'create', id: s.id, x:s.x, y:s.y, html: s.html});
    });

    // ---- graph modal ----
    document.getElementById('draw-graph').onclick = ()=>{
      const val = document.getElementById('graph-data').value;
      const arr = val.split(',').map(s=>parseFloat(s.trim())).filter(n=>!isNaN(n));
      if(arr.length===0) return alert('Enter numbers');
      drawNiceGraph(arr);
      sendMessage({type:'graph', data: arr});
      graphModal.style.display='none';
    };
    document.getElementById('close-graph').onclick = ()=> graphModal.style.display='none';
    graphBtn.addEventListener('click', ()=> graphModal.style.display='block');

    function drawNiceGraph(arr){
      const padding = 40, w = Math.min(600, canvas.width-80), h = Math.min(360, canvas.height-120);
      const gx = 30, gy = 30;
      // draw background
      ctx.save();
      ctx.strokeStyle = '#0b2340'; ctx.fillStyle='#f8fafc'; ctx.lineWidth = 1;
      // compute area - draw axes on top-left area
      const ax = 40, ay = 40, aw = Math.min(500, canvas.width-120), ah = Math.min(300, canvas.height-160);
      // clear small area
      ctx.clearRect(ax-2, ay-2, aw+4, ah+4);
      // border
      ctx.strokeStyle = '#0a2540'; ctx.strokeRect(ax, ay, aw, ah);
      // grid lines
      ctx.strokeStyle = '#e6eef8'; ctx.lineWidth = 0.6;
      const rows = 4;
      for(let r=0;r<=rows;r++){ const y = ay + (r/rows)*ah; ctx.beginPath(); ctx.moveTo(ax,y); ctx.lineTo(ax+aw,y); ctx.stroke(); }
      // plot
      const max = Math.max(...arr), min = Math.min(...arr);
      ctx.beginPath(); ctx.strokeStyle = '#7c3aed'; ctx.lineWidth = 2;
      arr.forEach((v,i)=>{
        const x = ax + (i/(arr.length-1||1)) * (aw-10);
        const y = ay + ah - ((v - min)/(max-min||1))*(ah-10);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        // dot
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
      });
      ctx.stroke();
      // labels
      ctx.fillStyle = '#071029'; ctx.font = '12px Inter, Arial'; ctx.fillText('Graph', ax+6, ay-8);
      ctx.restore();
    }

    // ---- voice / simple audio not included for brevity ----

    // ---- message handling ----
    function handleMessage(msg){
      if(msg.type==='sync'){
        // initial sync: history + stickies
        clientsEl.textContent = msg.clients || 0;
        // apply stickies
        if(Array.isArray(msg.stickies)){
          msg.stickies.forEach(s=> createStickyElement(s));
        }
        // apply history (draw commands)
        if(Array.isArray(msg.history)){
          msg.history.forEach(m=> handleMessage(m));
        }
        return;
      }
      if(msg.type==='clients'){ clientsEl.textContent = msg.count; return; }
      if(msg.type==='draw'){
        if(msg.sub==='free'){ drawLine(msg.x1,msg.y1,msg.x2,msg.y2,msg.color,msg.size); }
        else if(msg.sub==='eraser'){ drawLine(msg.x1,msg.y1,msg.x2,msg.y2,'#ffffff', msg.size); }
        else if(msg.sub==='line'){ drawLine(msg.x1,msg.y1,msg.x2,msg.y2,msg.color,msg.size); }
        else if(msg.sub==='rect'){ drawRect(msg.x,msg.y,msg.w,msg.h,msg.color,msg.size); }
        else if(msg.sub==='circle'){ drawCircle(msg.x,msg.y,msg.r,msg.color,msg.size); }
        return;
      }
      if(msg.type==='clear'){ ctx.clearRect(0,0,canvas.width,canvas.height); if(gridOn) drawGrid(); return; }
      if(msg.type==='graph'){ if(Array.isArray(msg.data)) drawNiceGraph(msg.data); return; }

      if(msg.type==='sticky'){
        const action = msg.action;
        const id = msg.id;
        if(action==='create'){
          createStickyElement(msg);
        }else if(action==='edit'){
          const el = stickies[id];
          if(el){ const content = el.querySelector('.content'); if(content) content.innerHTML = msg.html || ''; }
        }else if(action==='move'){
          const el = stickies[id];
          if(el){ el.style.left = (msg.x || 60) + 'px'; el.style.top = (msg.y || 60) + 'px'; }
        }else if(action==='delete'){
          const el = stickies[id];
          if(el){ el.remove(); delete stickies[id]; }
        }
        return;
      }

      if(msg.type==='voice'){
        // receive base64 and play
        const b64 = msg.data, mime = msg.mime || 'audio/webm';
        const blob = b64ToBlob(b64, mime); const url = URL.createObjectURL(blob);
        const a = document.createElement('audio'); a.controls=true; a.src=url; document.body.appendChild(a); a.play().catch(()=>{});
        return;
      }
    }

    function b64ToBlob(b64, mime){
      const bytes = atob(b64); const out = new Uint8Array(bytes.length);
      for(let i=0;i<bytes.length;i++) out[i]=bytes.charCodeAt(i);
      return new Blob([out], {type:mime});
    }

    // ---- grid drawing ----
    function drawGrid(){
      const step = 32; ctx.save(); ctx.strokeStyle = '#f1f5f9'; ctx.globalAlpha = 0.06;
      for(let x=0;x<canvas.width;x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=0;y<canvas.height;y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
      ctx.restore();
    }

    function redrawCanvas(){ /* placeholder for re-render from history if implemented; noop for now */ }

    // ---- init welcome sticky ----
    // create a local welcome sticky but let server assign authoritative id if needed
    const welcomeId = 'welcome-' + Date.now();
    createStickyElement({id: welcomeId, x:20, y:20, html: '<b>Welcome</b><br>Use the toolbar to draw. Drag the handle to move. Double-click the handle to delete.'});
  </script>
</body>
</html>