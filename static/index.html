<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Collaborative Multi-Whiteboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#020617;
      --panel:#02091d;
      --muted:#94a3b8;
      --accent:#7c3aed;
      --accent-soft:rgba(124,58,237,0.16);
      --toolbar-h:64px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:Inter,system-ui,Arial;
      height:100vh;
      display:flex;
      flex-direction:column;
      background:radial-gradient(circle at top left,#0b1120 0,#020617 55%);
      color:#e5e7eb;
    }
    #toolbar{
      height:var(--toolbar-h);
      display:flex;
      align-items:center;
      padding:10px 16px;
      background:linear-gradient(90deg, rgba(15,23,42,.95), rgba(15,23,42,.8));
      gap:12px;
      backdrop-filter:blur(8px);
      border-bottom:1px solid rgba(148,163,184,0.1);
      z-index:5;
    }
    .group{
      display:flex;
      align-items:center;
      gap:8px;
      background:rgba(15,23,42,0.9);
      padding:8px;
      border-radius:14px;
      box-shadow:0 12px 30px rgba(15,23,42,0.7);
    }
    button,input,select,textarea{font-family:inherit;font-size:14px}
    button{
      background:transparent;
      border:1px solid rgba(148,163,184,0.2);
      color:var(--muted);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      transition:.15s all ease-out;
    }
    button:hover{border-color:var(--accent);color:#e5e7eb}
    button.active{
      border-color:var(--accent);
      box-shadow:0 8px 24px var(--accent-soft);
      color:#f9fafb;
      background:rgba(124,58,237,0.14);
    }
    #left{display:flex;gap:10px;align-items:center}
    #right{margin-left:auto;display:flex;gap:10px;align-items:center;color:var(--muted)}
    #canvas-wrap{
      position:relative;
      flex:1;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:10px 14px 16px;
    }
    #board-tabs{
      display:flex;
      gap:8px;
      padding:0 2px;
    }
    .tab{
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,23,42,0.92);
      color:var(--muted);
      border:1px solid rgba(148,163,184,0.3);
      cursor:pointer;
      font-size:13px;
    }
    .tab.active{
      background:rgba(15,23,42,1);
      color:#e5e7eb;
      border-color:var(--accent);
      box-shadow:0 8px 20px var(--accent-soft);
    }
    .tab.add{
      padding-inline:9px;
      border-style:dashed;
    }
    #canvas-shell{
      position:relative;
      flex:1;
      display:flex;
      justify-content:center;
      align-items:center;
    }
    #canvas{
      border-radius:16px;
      background:#ffffff;
      display:block;
      cursor:crosshair;
      box-shadow:0 18px 45px rgba(15,23,42,0.85);
      max-width:100%;
      max-height:100%;
    }
    #sticky-area{
      position:absolute;
      inset:50px 40px 24px 40px;
      pointer-events:none;
    }
    .sticky{
      position:absolute;
      width:220px;
      min-height:110px;
      background:linear-gradient(180deg,#fff8b3,#fff1a8);
      color:#111827;
      padding:10px;
      box-shadow:0 18px 40px rgba(15,23,42,0.85);
      resize:both;
      overflow:auto;
      pointer-events:auto;
      border-radius:10px;
      border:1px solid rgba(15,23,42,0.18);
    }
    .sticky .handle{
      display:block;
      background:linear-gradient(90deg,#f97316,#f59e0b);
      height:18px;
      border-radius:6px;
      margin-bottom:6px;
      cursor:grab;
    }
    .sticky textarea{
      width:100%;
      min-height:60px;
      border-radius:6px;
      border:1px solid rgba(15,23,42,0.18);
      padding:6px;
      font-family:inherit;
      font-size:13px;
      resize:none;
      background:rgba(255,255,255,0.9);
    }
    #graph-modal{
      position:fixed;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      background:#020617;
      padding:18px 18px 16px;
      border-radius:14px;
      box-shadow:0 24px 70px rgba(15,23,42,0.9);
      display:none;
      z-index:50;
      width:440px;
      color:#e5e7eb;
      border:1px solid rgba(148,163,184,0.25);
    }
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type="text"]{
      padding:8px;
      border-radius:8px;
      border:1px solid rgba(148,163,184,0.4);
      background:transparent;
      color:#e5e7eb;
      width:100%;
    }
    select{padding:4px 6px;border-radius:6px;border:1px solid rgba(148,163,184,0.4);background:#020617;color:#e5e7eb}
    .small-muted{font-size:12px;color:var(--muted)}
    #clients{
      min-width:30px;
      text-align:center;
      background:rgba(15,23,42,0.9);
      padding:6px;
      border-radius:9px;
      border:1px solid rgba(148,163,184,0.4);
    }
    .toolbar-icon{
      width:36px;
      height:36px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:10px;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div id="left" class="group">
      <button id="tool-pen" class="active toolbar-icon" title="Pen">‚úèÔ∏è</button>
      <button id="tool-eraser" class="toolbar-icon" title="Eraser">üßΩ</button>
      <div style="display:flex;flex-direction:column">
        <label class="small-muted">Color</label>
        <input id="color" type="color" value="#000000">
      </div>
      <div style="display:flex;flex-direction:column">
        <label class="small-muted">Size</label>
        <input id="size" type="range" min="1" max="30" value="3">
      </div>
      <div style="display:flex;flex-direction:column">
        <label class="small-muted">Shape</label>
        <select id="shape-select">
          <option value="none">Freehand</option>
          <option value="line">Line</option>
          <option value="rect">Rectangle</option>
          <option value="circle">Circle</option>
        </select>
      </div>
      <button id="quickshape-toggle" class="toolbar-icon" title="Quick Shape">‚óé</button>
      <button id="toggle-grid" class="toolbar-icon" title="Toggle grid">‚ñ¶</button>
      <button id="add-sticky" class="toolbar-icon" title="Add note">üóíÔ∏è</button>
      <button id="graph-btn" class="toolbar-icon" title="Graphs">üìä</button>
      <button id="clear" class="toolbar-icon" title="Clear">üßπ</button>
    </div>
    <div id="right">
      <div class="small-muted">Connected</div>
      <div id="clients" title="Connected clients">0</div>
      <div class="small-muted">Status</div>
      <div id="status" class="small-muted">Ready</div>
    </div>
  </div>

  <div id="canvas-wrap">
    <div id="board-tabs"></div>
    <div id="canvas-shell">
      <canvas id="canvas"></canvas>
      <div id="sticky-area"></div>
    </div>
  </div>

  <div id="graph-modal">
    <h3 style="margin:0 0 8px 0">Insert graph data</h3>
    <label>Graph type</label>
    <select id="graph-type">
      <option value="line">Line graph</option>
      <option value="bar">Bar chart</option>
      <option value="histogram">Histogram</option>
      <option value="pie">Pie chart</option>
    </select>
    <label style="margin-top:10px;">Values (comma-separated)</label>
    <input id="graph-data" type="text" placeholder="e.g. 10, 20, 15, 30, 50">
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
      <button id="draw-graph">Draw</button>
      <button id="close-graph">Close</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const colorPicker = document.getElementById('color');
    const sizePicker = document.getElementById('size');
    const clearBtn = document.getElementById('clear');
    const clientsEl = document.getElementById('clients');
    const stickyArea = document.getElementById('sticky-area');
    const toggleGridBtn = document.getElementById('toggle-grid');
    const addStickyBtn = document.getElementById('add-sticky');
    const graphBtn = document.getElementById('graph-btn');
    const graphModal = document.getElementById('graph-modal');
    const graphTypeSel = document.getElementById('graph-type');
    const statusEl = document.getElementById('status');
    const quickShapeBtn = document.getElementById('quickshape-toggle');
    const tabsContainer = document.getElementById('board-tabs');

    let currentTool = 'pen';
    let currentShape = 'none';
    let drawing = false;
    let lastX = 0, lastY = 0;
    let shapeStart = null;
    let gridOn = false;
    let quickShape = false;

    // multi-board
    let currentBoard = 0;
    const MAX_BOARDS = 6;

    // per-board history & stickies (client-side)
    const boardState = {
      0: { history: [], stickies: {} }
    };

    const strokePoints = [];

    // websocket
    const wsScheme = location.protocol === 'https:' ? 'wss' : 'ws';
    const socket = new WebSocket(`${wsScheme}://${location.host}/ws`);

    socket.addEventListener('open', ()=>{ statusEl.textContent='Connected'; });
    socket.addEventListener('close', ()=>{ statusEl.textContent='Disconnected'; });
    socket.addEventListener('error', ()=>{ statusEl.textContent='Error'; });

    socket.addEventListener('message', (evt)=>{
      try{
        const msg = JSON.parse(evt.data);
        handleMessage(msg, false);
      }catch(e){ console.error('Invalid ws msg', e); }
    });

    function sendMessage(obj){
      handleMessage(obj, true);
      try{
        socket.send(JSON.stringify(obj));
      }catch(e){ console.error(e); }
    }

    // HiDPI canvas
    function resizeCanvas(){
      const toolbarH = document.getElementById('toolbar').offsetHeight;
      const displayWidth = Math.max(840, Math.min(window.innerWidth-64, 1440));
      const displayHeight = Math.max(420, window.innerHeight - toolbarH - 72);
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';
      canvas.width = displayWidth * dpr;
      canvas.height = displayHeight * dpr;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      redrawCanvasForBoard();
      if(gridOn) drawGrid();
    }
    window.addEventListener('resize', resizeCanvas);

    function activeHistory(){
      if(!boardState[currentBoard]) boardState[currentBoard] = {history:[], stickies:{}};
      return boardState[currentBoard].history;
    }
    function activeStickiesMap(){
      if(!boardState[currentBoard]) boardState[currentBoard] = {history:[], stickies:{}};
      return boardState[currentBoard].stickies;
    }

    // drawing primitives
    function drawLine(x1,y1,x2,y2,color,size,composite='source-over'){
      ctx.globalCompositeOperation = composite;
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.globalCompositeOperation = 'source-over';
    }
    function drawRect(x,y,w,h,color,size){
      ctx.lineWidth = size; ctx.strokeStyle = color;
      ctx.strokeRect(x,y,w,h);
    }
    function drawCircle(cx,cy,r,color,size){
      ctx.lineWidth = size; ctx.strokeStyle = color;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
    }

    // tools
    document.getElementById('tool-pen').onclick = ()=> selectTool('pen');
    document.getElementById('tool-eraser').onclick = ()=> selectTool('eraser');
    quickShapeBtn.onclick = ()=>{
      quickShape = !quickShape;
      quickShapeBtn.classList.toggle('active', quickShape);
    };
    function selectTool(t){
      currentTool = t;
      document.querySelectorAll('.toolbar-icon').forEach(b=>b.classList.remove('active'));
      if(t==='pen') document.getElementById('tool-pen').classList.add('active');
      else document.getElementById('tool-eraser').classList.add('active');
    }
    document.getElementById('shape-select').addEventListener('change', e=>{
      currentShape = e.target.value;
    });
    toggleGridBtn.addEventListener('click', ()=>{
      gridOn = !gridOn;
      redrawCanvasForBoard();
      if(gridOn) drawGrid();
      toggleGridBtn.classList.toggle('active', gridOn);
    });

    // pointer utilities
    function getCanvasPos(evt){
      const rect = canvas.getBoundingClientRect();
      return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    // freehand + shapes + quick shape
    canvas.addEventListener('mousedown', e=>{
      drawing = true;
      const pos = getCanvasPos(e);
      lastX = pos.x; lastY = pos.y;
      shapeStart = {x:lastX,y:lastY};
      strokePoints.length = 0;
      strokePoints.push({x:lastX,y:lastY});
    });

    canvas.addEventListener('mouseup', e=>{
      if(!drawing) return;
      drawing = false;
      const pos = getCanvasPos(e);
      const x = pos.x, y = pos.y;
      const color = colorPicker.value, size = parseInt(sizePicker.value,10);

      if(currentShape!=='none'){
        if(currentShape==='line'){
          sendMessage({board:currentBoard,type:'draw',sub:'line',x1:shapeStart.x,y1:shapeStart.y,x2:x,y2:y,color,size});
        }else if(currentShape==='rect'){
          sendMessage({board:currentBoard,type:'draw',sub:'rect',x:shapeStart.x,y:shapeStart.y,w:x-shapeStart.x,h:y-shapeStart.y,color,size});
        }else if(currentShape==='circle'){
          const dx=x-shapeStart.x,dy=y-shapeStart.y,r=Math.hypot(dx,dy);
          sendMessage({board:currentBoard,type:'draw',sub:'circle',x:shapeStart.x,y:shapeStart.y,r,color,size});
        }
        shapeStart=null;
        return;
      }

      // freehand + quick shape
      if(currentTool==='pen' && quickShape){
        strokePoints.push({x,y});
        const cmd = recognizeQuickShape(strokePoints,color,size);
        if(cmd){
          cmd.board = currentBoard;
          sendMessage(cmd);
        }else{
          // send as simple path
          for(let i=1;i<strokePoints.length;i++){
            const p0=strokePoints[i-1], p1=strokePoints[i];
            sendMessage({board:currentBoard,type:'draw',sub:'free',x1:p0.x,y1:p0.y,x2:p1.x,y2:p1.y,color,size});
          }
        }
      }
      strokePoints.length=0;
    });

    canvas.addEventListener('mousemove', e=>{
      if(!drawing) return;
      const pos = getCanvasPos(e);
      const x = pos.x, y = pos.y;
      const color = colorPicker.value, size = parseInt(sizePicker.value,10);

      if(currentShape==='none'){
        if(currentTool==='pen'){
          if(quickShape){
            strokePoints.push({x,y});
            redrawCanvasForBoard();
            if(gridOn) drawGrid();
            // preview stroke
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap='round';
            ctx.beginPath();
            ctx.moveTo(strokePoints[0].x, strokePoints[0].y);
            for(let i=1;i<strokePoints.length;i++){
              ctx.lineTo(strokePoints[i].x, strokePoints[i].y);
            }
            ctx.stroke();
            ctx.restore();
          }else{
            const cmd = {board:currentBoard,type:'draw',sub:'free',x1:lastX,y1:lastY,x2:x,y2:y,color,size};
            sendMessage(cmd);
          }
        }else if(currentTool==='eraser'){
          const cmd = {board:currentBoard,type:'draw',sub:'eraser',x1:lastX,y1:lastY,x2:x,y2:y,size:size*3};
          sendMessage(cmd);
        }
        lastX = x; lastY = y;
      }else{
        redrawCanvasForBoard();
        if(gridOn) drawGrid();
        const sx=shapeStart.x, sy=shapeStart.y;
        ctx.save();
        ctx.setLineDash([6,4]);
        ctx.strokeStyle = color;
        ctx.lineWidth=size;
        if(currentShape==='line'){
          ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(x,y); ctx.stroke();
        }else if(currentShape==='rect'){
          ctx.strokeRect(sx,sy,x-sx,y-sy);
        }else if(currentShape==='circle'){
          const dx=x-sx,dy=y-sy,r=Math.hypot(dx,dy);
          ctx.beginPath(); ctx.arc(sx,sy,r,0,Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      }
    });

    clearBtn.addEventListener('click', ()=>{
      sendMessage({board:currentBoard,type:'clear'});
    });

    // QuickShape recognizer improved: distinguishes circle vs rectangle, treats arrows as lines
    function recognizeQuickShape(points,color,size){
      if(points.length<6) return null;
      const first=points[0], last=points[points.length-1];

      // path length & straightness
      let pathLen=0;
      for(let i=1;i<points.length;i++){
        const dx=points[i].x-points[i-1].x;
        const dy=points[i].y-points[i-1].y;
        pathLen+=Math.hypot(dx,dy);
      }
      const dxFL=last.x-first.x, dyFL=last.y-first.y;
      const distFL=Math.hypot(dxFL,dyFL);

      // bounds
      let minX=points[0].x,maxX=points[0].x,minY=points[0].y,maxY=points[0].y;
      for(const p of points){
        if(p.x<minX) minX=p.x;
        if(p.x>maxX) maxX=p.x;
        if(p.y<minY) minY=p.y;
        if(p.y>maxY) maxY=p.y;
      }
      const w=maxX-minX, h=maxY-minY;

      // 1. Straight line / arrow (treat arrow as line)
      const straightness = distFL / (pathLen||1);
      if(straightness > 0.9 && pathLen > 30){
        return {type:'draw',sub:'line',x1:first.x,y1:first.y,x2:last.x,y2:last.y,color,size};
      }

      const closed = distFL < Math.max(w,h)*0.25;
      if(!closed) return null; // unrecognized open scribble

      // center & radial variance
      const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
      let sumR=0, sumR2=0;
      for(const p of points){
        const r=Math.hypot(p.x-cx,p.y-cy);
        sumR+=r; sumR2+=r*r;
      }
      const meanR=sumR/points.length;
      const varR=(sumR2/points.length) - meanR*meanR;
      const aspect=w/(h||1);

      // circle if radii almost constant
      const normalizedVar = varR/(meanR*meanR || 1);
      // treat as circle only if radii are very even AND width~height
      if(normalizedVar < 0.03 && aspect>0.85 && aspect<1.15){
        const r=(w+h)/4;
        return {type:'draw',sub:'circle',x:cx,y:cy,r,color,size};
      }

      // otherwise prefer rectangle / square
      return {type:'draw',sub:'rect',x:minX,y:minY,w:w,h:h,color,size};
    }

    // Sticky notes ‚Äì fix disappearing text by not overwriting local values
    const globalStickies = {}; // across boards but we mount only current board's

    function createStickyElement(s){
      const boardStickies = activeStickiesMap();
      if(boardStickies[s.id]) return boardStickies[s.id];
      const el=document.createElement('div');
      el.className='sticky';
      el.style.left=(s.x||80)+'px';
      el.style.top=(s.y||80)+'px';
      el.style.zIndex=s.z||1;
      el.dataset.id=s.id;
      el.dataset.board=s.board;

      const handle=document.createElement('div');
      handle.className='handle';
      el.appendChild(handle);

      const textarea=document.createElement('textarea');
      textarea.value = s.text || '';
      el.appendChild(textarea);

      stickyArea.appendChild(el);
      makeDraggable(el, handle);

      textarea.addEventListener('input', ()=>{
        // local update; server echo will not overwrite because we check local flag
        sendMessage({board:currentBoard,type:'sticky',action:'edit',id:el.dataset.id,text:textarea.value});
      });

      handle.addEventListener('dblclick', ()=>{
        const id=el.dataset.id;
        el.remove();
        delete boardStickies[id];
        sendMessage({board:currentBoard,type:'sticky',action:'delete',id});
      });

      boardStickies[s.id]=el;
      globalStickies[s.id]=el;
      return el;
    }

    function makeDraggable(el, handle){
      handle.addEventListener('mousedown', e=>{
        e.preventDefault();
        let startX=e.clientX,startY=e.clientY;
        const startLeft=parseInt(el.style.left||0,10);
        const startTop=parseInt(el.style.top||0,10);
        function mm(ev){
          const nx=startLeft+(ev.clientX-startX);
          const ny=startTop+(ev.clientY-startY);
          el.style.left=nx+'px';
          el.style.top=ny+'px';
        }
        function mu(ev){
          document.removeEventListener('mousemove',mm);
          document.removeEventListener('mouseup',mu);
          sendMessage({board:currentBoard,type:'sticky',action:'move',id:el.dataset.id,x:parseInt(el.style.left),y:parseInt(el.style.top)});
        }
        document.addEventListener('mousemove',mm);
        document.addEventListener('mouseup',mu);
      });
    }

    addStickyBtn.addEventListener('click', ()=>{
      const id='s-'+Date.now()+'-'+Math.floor(Math.random()*1000);
      const s={id,board:currentBoard,x:90,y:90,text:''};
      createStickyElement(s);
      sendMessage({board:currentBoard,type:'sticky',action:'create',id:s.id,x:s.x,y:s.y,text:s.text});
    });

    // Graphs: line, bar, histogram, pie
    document.getElementById('draw-graph').onclick = ()=>{
      const val=document.getElementById('graph-data').value;
      const arr=val.split(',').map(s=>parseFloat(s.trim())).filter(n=>!isNaN(n));
      if(arr.length===0){ alert('Enter numbers'); return; }
      const gType = graphTypeSel.value;
      sendMessage({board:currentBoard,type:'graph',graphType:gType,data:arr});
      graphModal.style.display='none';
    };
    document.getElementById('close-graph').onclick = ()=> graphModal.style.display='none';
    graphBtn.addEventListener('click', ()=> graphModal.style.display='block');

    function drawGraph(cmd){
      const arr = cmd.data;
      if (!Array.isArray(arr) || !arr.length) return;

      const width = canvas.width / (window.devicePixelRatio || 1);
      const height = canvas.height / (window.devicePixelRatio || 1);

      // chart area
      const ax = 60, ay = 40;
      const aw = Math.min(520, width - 120);
      const ah = Math.min(320, height - 160);

      ctx.save();
      ctx.clearRect(ax - 6, ay - 6, aw + 12, ah + 12);

      // axes box
      ctx.strokeStyle = '#0f172a';
      ctx.lineWidth = 1;
      ctx.strokeRect(ax, ay, aw, ah);

      // grid lines
      ctx.strokeStyle = '#e2e8f0';
      ctx.globalAlpha = 0.45;
      ctx.lineWidth = 0.6;

      const rows = 4;
      for (let r = 0; r <= rows; r++) {
        const y = ay + (r / rows) * ah;
        ctx.beginPath();
        ctx.moveTo(ax, y);
        ctx.lineTo(ax + aw, y);
        ctx.stroke();
      }

      ctx.globalAlpha = 1;

      const max = Math.max(...arr);
      const min = Math.min(...arr);
      const span = (max - min) || 1;
      const type = cmd.graphType || 'line';

      // Y-axis labels (min .. max)
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '11px Inter, system-ui, sans-serif';
      for (let r = 0; r <= rows; r++) {
        const value = min + (span * (rows - r) / rows);
        const y = ay + (r / rows) * ah + 3;
        ctx.fillText(value.toFixed(1), ax - 40, y);
      }

      // X-axis labels (1..n)
      arr.forEach((v, i) => {
        const x = ax + (i + 0.5) * (aw / arr.length);
        ctx.fillText(String(i + 1), x - 4, ay + ah + 14);
      });

      const palette = ['#6366f1','#f97316','#10b981','#ec4899','#eab308','#22c55e','#3b82f6'];

      if (type === 'line') {
        ctx.lineWidth = 2;
        // multi-colour segments
        for (let i = 0; i < arr.length - 1; i++) {
          const v1 = arr[i], v2 = arr[i+1];
          const x1 = ax + (i / (arr.length - 1 || 1)) * (aw - 20) + 10;
          const y1 = ay + ah - ((v1 - min) / span) * (ah - 20);
          const x2 = ax + ((i+1) / (arr.length - 1 || 1)) * (aw - 20) + 10;
          const y2 = ay + ah - ((v2 - min) / span) * (ah - 20);
          ctx.strokeStyle = palette[i % palette.length];
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          // points
          ctx.fillStyle = '#ffffff';
          ctx.beginPath(); ctx.arc(x1, y1, 3, 0, Math.PI * 2); ctx.fill();
          if (i === arr.length - 2) {
            ctx.beginPath(); ctx.arc(x2, y2, 3, 0, Math.PI * 2); ctx.fill();
          }
        }
      } else if (type === 'bar' || type === 'histogram') {
        const barW = aw / arr.length * 0.7;
        arr.forEach((v, i) => {
          const x = ax + (i + 0.15) * (aw / arr.length);
          const hVal = ((v - min) / span) * (ah - 20);
          const y = ay + ah - hVal;
          ctx.fillStyle = palette[i % palette.length];
          ctx.fillRect(x, y, barW, hVal);
        });
      } else if (type === 'pie') {
        const cx = ax + aw / 2;
        const cy = ay + ah / 2;
        const r = Math.min(aw, ah) / 2 - 24;
        const sum = arr.reduce((a,b) => a + b, 0) || 1;
        let startAng = -Math.PI / 2;
        arr.forEach((v, i) => {
          const slice = (v / sum) * Math.PI * 2;
          const mid = startAng + slice / 2;
          const color = palette[i % palette.length];

          // slice
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.fillStyle = color;
          ctx.arc(cx, cy, r, startAng, startAng + slice);
          ctx.closePath();
          ctx.fill();

          // percentage label
          const pct = (v / sum) * 100;
          const lx = cx + Math.cos(mid) * (r + 12);
          const ly = cy + Math.sin(mid) * (r + 12);
          ctx.fillStyle = '#e5e7eb';
          ctx.font = '11px Inter, system-ui, sans-serif';
          ctx.fillText(pct.toFixed(1) + '%', lx - 14, ly);

          startAng += slice;
        });
      }

      ctx.restore();
    }
    }

    // Grid
    function drawGrid(){
      const step=32;
      const width=canvas.width/(window.devicePixelRatio||1);
      const height=canvas.height/(window.devicePixelRatio||1);
      ctx.save();
      ctx.strokeStyle='#e2e8f0';
      ctx.globalAlpha=0.12;
      for(let x=0;x<width;x+=step){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke();
      }
      for(let y=0;y<height;y+=step){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke();
      }
      ctx.restore();
    }

    function redrawCanvasForBoard(){
      const width=canvas.width/(window.devicePixelRatio||1);
      const height=canvas.height/(window.devicePixelRatio||1);
      ctx.clearRect(0,0,width,height);
      const hist=activeHistory();
      hist.forEach(cmd=>{
        if(cmd.type==='draw'){
          if(cmd.sub==='free'){ drawLine(cmd.x1,cmd.y1,cmd.x2,cmd.y2,cmd.color,cmd.size); }
          else if(cmd.sub==='eraser'){ drawLine(cmd.x1,cmd.y1,cmd.x2,cmd.y2,'#ffffff',cmd.size); }
          else if(cmd.sub==='line'){ drawLine(cmd.x1,cmd.y1,cmd.x2,cmd.y2,cmd.color,cmd.size); }
          else if(cmd.sub==='rect'){ drawRect(cmd.x,cmd.y,cmd.w,cmd.h,cmd.color,cmd.size); }
          else if(cmd.sub==='circle'){ drawCircle(cmd.x,cmd.y,cmd.r,cmd.color,cmd.size); }
        }else if(cmd.type==='graph'){
          drawGraph(cmd);
        }
      });
      // rebuild stickies for active board
      stickyArea.innerHTML='';
      const map=activeStickiesMap();
      Object.values(map).forEach(el=> stickyArea.appendChild(el));
    }

    // multi-board tabs
    function renderTabs(){
      tabsContainer.innerHTML='';
      for(let i=0;i<=Object.keys(boardState).length-1;i++){
        const tab=document.createElement('button');
        tab.className='tab'+(i===currentBoard?' active':'');
        tab.textContent='Board '+(i+1);
        tab.onclick = ()=>{ switchBoard(i); };
        tabsContainer.appendChild(tab);
      }
      if(Object.keys(boardState).length<MAX_BOARDS){
        const add=document.createElement('button');
        add.className='tab add';
        add.textContent='+ Board';
        add.onclick = ()=>{
          const idx=Object.keys(boardState).length;
          boardState[idx]={history:[], stickies:{}};
          currentBoard=idx;
          renderTabs();
          redrawCanvasForBoard();
          if(gridOn) drawGrid();
        };
        tabsContainer.appendChild(add);
      }
    }

    function switchBoard(idx){
      currentBoard=idx;
      renderTabs();
      redrawCanvasForBoard();
      if(gridOn) drawGrid();
    }

    // message handler ‚Äì respect board field
    function handleMessage(msg, local){
      const board = msg.board ?? 0;
      if(!boardState[board]) boardState[board]={history:[], stickies:{}};

      if(msg.type==='sync'){
        // this project uses stateless broadcast server earlier; if server upgraded to send sync we would hydrate here
        if(msg.clients!=null) clientsEl.textContent=msg.clients;
        return;
      }
      if(msg.type==='clients'){
        clientsEl.textContent=msg.count;
        return;
      }
      if(msg.type==='draw'){
        const hist=boardState[board].history;
        if(!local) hist.push(msg);
        if(board===currentBoard){
          if(msg.sub==='free'){ drawLine(msg.x1,msg.y1,msg.x2,msg.y2,msg.color,msg.size); }
          else if(msg.sub==='eraser'){ drawLine(msg.x1,msg.y1,msg.x2,msg.y2,'#ffffff',msg.size); }
          else if(msg.sub==='line'){ drawLine(msg.x1,msg.y1,msg.x2,msg.y2,msg.color,msg.size); }
          else if(msg.sub==='rect'){ drawRect(msg.x,msg.y,msg.w,msg.h,msg.color,msg.size); }
          else if(msg.sub==='circle'){ drawCircle(msg.x,msg.y,msg.r,msg.color,msg.size); }
        }
        return;
      }
      if(msg.type==='clear'){
        boardState[board].history.length=0;
        if(board===currentBoard){
          const width=canvas.width/(window.devicePixelRatio||1);
          const height=canvas.height/(window.devicePixelRatio||1);
          ctx.clearRect(0,0,width,height);
          if(gridOn) drawGrid();
        }
        return;
      }
      if(msg.type==='graph'){
        const hist=boardState[board].history;
        if(!local) hist.push(msg);
        if(board===currentBoard) drawGraph(msg);
        return;
      }
      if(msg.type==='sticky'){
        const map = boardState[board].stickies;
        const id = msg.id;
        if(msg.action==='create'){
          const s={id:msg.id,board, x:msg.x,y:msg.y,text:msg.text||''};
          if(board===currentBoard) createStickyElement(s);
          else map[id]=s; // will render when switched
        }else if(msg.action==='edit'){
          // For sender: we already updated textarea locally in input handler
          if(local) return;
          const el = globalStickies[id];
          if(!el) return;
          const textarea = el.querySelector('textarea');
          // If user is currently typing in this note, don't overwrite their caret
          if(document.activeElement === textarea) return;
          if(textarea) textarea.value = msg.text || '';
        }else if(msg.action==='move'){
          const el = globalStickies[id];
          if(el){
            el.style.left=(msg.x||80)+'px';
            el.style.top=(msg.y||80)+'px';
          }
        }else if(msg.action==='delete'){
          const el = globalStickies[id];
          if(el){
            el.remove();
            delete globalStickies[id];
          }
          delete map[id];
        }
        return;
      }
    }

    // init
    renderTabs();
    resizeCanvas();
  </script>
</body>
</html>